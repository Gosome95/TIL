# 열거형식(Enumerator)과 구조체(Structure)

> 책 [박상현 : 이것이 C#이다](http://aladin.kr/p/YysOb) 를 참고하였습니다 </br> 
> 인프런 `Rookiss`님의 [<C#과 유니티로 만드는 MMORPG게임 개발 시리즈 Part1:C#기본문법>](https://inf.run/CJG3) 내용을 보고 공부목적으로 작성한 글 입니다.

## 상수(Constants)와 열거형식(Enumerator)

- 변수와 달리 안에 담긴 데이터를 절대 바꿀 수 없는 메모리 공간 
- "값을 바꾸지 말아야 할 변수"를 건드리는 실수 방지 
	- 컴파일러가 소스 코드를 컴파일 할 때 프로그래머의 실수를 잡아 알려주고, 프로그램의 버그도 줄여준다

### 상수(Constants)
- 데이터 형식 앞에 `const` 키워드 위치 
- 상수가 가져야 하는 데이터를 반드시 대입해줘야 한다 
```cs
const 자료형 상수명 = 값;

const int a = 3;
const double b = 3.14;
const string c = "abcedef";

a = 4;   // 컴파일 에러를 뱉어줌 
```

### 열거 형식 (Enumerator) - 여러 개의 상수를 정리 
- 종류는 같지만 다른 값을 갖는 상수를 선언해야 할 때 
- **`열거 형식`은 같은 범주에 속하는 여러 개의 상수를 선언할 때 유용하다** 
	- 수백 개의 상수 중에서 만약 중복되는 값을 갖는 상수들이 존재하는 실수를 막아주는 장치
```cs
enum 열거 형식명 : 기반자료형 
{상수1, 상수2, 상수3, ...}

enum 열거형식명 
{
	상수1 = 값1,
	상수2 = 값2,
	상수3 = 값3, .... 	
}
```

- 기반 자료형은 정수 계열 `{byte, sbyte, short, ushort, int, uint, long, ulong, char}`
	- 생략할 경우 컴파일러가 `int`를 기반자료형으로 사용 
- 열거 형식 안에 선언된 상수들이 어떤 값도 할당받지 않으면?
	- 컴파일러가 첫번째 요소에 0, 그리고 1씩 증가한 값을 자동 할당 


#### 내가 선언한 `상수`에 어째서 컴파일러가 마음대로 값을 넣는가?
- 열거 형식의 요소가 어떤 값을 갖느냐는 별 의미가 없기 때문 
- 열거 형식의 각 요소는 서로 중복되지 않는 값을 갖고 있다는데 의미가 있다 
- **각 요소가 갖고 있는 값보다 <u>`각 요소의 이름`을 사용</u>하는 것이 그 의미에 잘 부합한다고 할 수 있다** 
```cs
enum ClassType
{
	None = 0,
	Knight = 1,
	Archer = 2,
	Mage = 3
 }
```
-  enum 구현부 안에 숫자는 반드시 {0, 1, 2, 3}일 필요 없고 {10, 15, 20} 같은 다른 값도 가능
-   `메모리` 상으로는 `일반 정수`이지만 C# 코드에선 `"1"` `"2"` `"3"` 같은 의미없는 하드코딩해서 넣는 것이 아니라 **`ClassType.Knight` 와 같이 알아보기 쉬운 값을 사용**할 수 있게 된다
```cs
DialogResult result = DialogResult.Yes;
```
- `DialogResult가 0이다` 보다는 `DialoResult가 Yes다` 가 훨씬 의미를 잘 전달하고 읽기 좋다.
- 헷갈릴 위험도 적고, 나중에 고치기도 쉬워진다 

</br>

- 앞에서 `enum ClassType` 라는 열거 형식을 선언했는데, `ClassType`는 변수가 아니고 `새로운 형식`!
- 담을 수 있는 데이터는 오로지 `ClassType` `형식`뿐인 새로운 사용자정의 형식 

## 구조체(Structure)
- 클래스(`class`)와 유사

| 특징          | 클래스(Class)                          | 구조체(Structure)                        |
| ------------- | ------------------------------ | -------------------------------- |
| 키워드        | class                          | struct                           |
| 형식          | 참조 형식<br>(힙에 할당)       | 값 형식<br>(스택에 할당)         |
| 복사          | 얕은 복사<br>Shallow Copy      | 깊은 복사<br>Deep Copy           |
| 인스턴스 생성 | new 연산자와 생성자 필요       | 선언만으로도 생성                |
| 생성자        | 매개변수 없는 생성자 선언 가능 | 매개변수 없는 생성자 선언 불가능 |
| 상속          | 가능                           | 값 형식이므로 상속 불가능        |


```cs
struct 구조체이름
{
	// 필드 ... 
	// 메소드 ... 
}
```
</br>

```cs
struct PlayerStatus
{
	public int hp;
	public int attack;
}
```
- 구조체의 필드를 `pulbic`으로 선언했다 
- 클래스는 실세계의 객체를 추상화하려는 데 그 존재의 이유가 있음 
- **<u>구조체는 데이터를 담기 위한 자료구조로 사용</u>** 
- 굳이 은닉성을 비롯한 객체지향의 원칙을 구조체에 강하게 적용하지 않는 편이며, 편의를 위해 `public`으로 선언해서 사용한다

- <u>**클래스는 참조형식이고 구조체는 값 형식**</u>
```cs
Playerstatus player1;
player1.hp = 100;
player1.attack = 10; 

// 구조체의 인스턴스를 다른 인스턴스에 할당하면 (인스턴스) 깊은 복사가 이루어진다 
Playerstatus Player2 = player1;   
palyer2.hp = 80; 

/////////////////
player1 {100, 10}
player2 {80, 10}
```
- 값 형식이기 때문에 모든 필드가 그대로 복사된다 

- 선언만으로도 인스턴스가 생성된다 
	- 생성자를 이용한 인스턴스 생성도 가능
	- 단, 매개변수가 없는 생성자는 선언할 수 없다.
	- 하지만 구조체의 각 필드는 `CLR`이 기본값으로 초기화를 해준다 

### [코드](https://github.com/Gosome95/TIL/blob/main/CSharp/TextRPG1_UseMethod/TextRPG1_02_MakePlayer.cs)에서 열겨형식과 구조체 
> **ClassType은 enum 형태로, Player Stat {hp, attack}은 sturct 형태로 구현한 이유?**

- ClassType은 Knight, Archer, Mage 같은 `직업 종류`를 묶어준다. 직업Class Type이라는 범주 안에서 <u>**Class(직업)를 말 그대로 나열한 형태로 사용**</u>
- 실제 ClassType 안에 들어있는 데이터 {0, 1, 2, 3}을 건드릴 일이 없다 
- 반면에 각 직업 안에 들어가는 스텟(stat)정보 `{hp, attack}`은 <u>**직접 데이터를 집어넣어서 조작이 필요**</u>하다 
- [Inflearn 질문 : 구조체는 어느 상황에 쓰이나요?](https://inflearn.com/questions/175799)
	- 열거형은 문자열, 정수 모두 됩니다.
		기본적으로 `열거형`은 1, 2, 3에 Orc, Skeleton, Slime같은 이름을 지어주는 셈이지 **자체로 데이터를 묶어서 관리하는 개념은 아닙니다.**
		반면 `struct`는 **진짜 데이터를 묶어서 관리**할 수 있게 해주는데
		가령 `hp`, `mp` 및 `기타 스탯`을 따로 따로 관리하기 보다는
		묶어서 관리할 수 있습니다 
		```cs
		struct StatInfo
		{
		int hp;
		int mp;
		int strength;
		int dexterity;
		}
		```
## Struct 와 Class 
| 특징 | 클래스(Class) | 구조체(Structure) |
| ------------- | ------------------------------ | -------------------------------- |
| 키워드 | class | struct |
| 형식 | 참조 형식<br>(힙에 할당) | 값 형식<br>(스택에 할당) |
| 복사 | 얕은 복사<br>Shallow Copy | 깊은 복사<br>Deep Copy |
| 인스턴스 생성 | new 연산자와 생성자 필요 | 선언만으로도 생성 |
| 생성자 | 매개변수 없는 생성자 선언 가능 | 매개변수 없는 생성자 선언 불가능 |
| 상속 | 가능 | 값 형식이므로 상속 불가능 |

-   class = 참조로 해서 값을 넘김
    -   쉽게 말해서 그냥 계속 ref로 작업하는 셈
    -  `class`는 참조 타입이라, `ref` 없이도 자체적으로 원본을 대상으로 연산

#### [C++ C# stuct 비교](https://inflearn.com/questions/139848)
`C++`에서 `C#`으로 넘어올 땐 한가지만 기억하면 편합니다.
`C#`의 `struct`는 `C++`의 `struct`처럼 <u>**복사**</u>가 되고,
`C#`의 `class`는 `C++`로 치면 항상 `*(pointer)`를 함축하고 있다고 생각하시면 됩니다.
`C# : struct Knight ->    C++ : Knight 복사`
`C# : class Knight -> C++ : Knight* or Knight&`

- **Struct 도 내부에 함수 생성이 가능한가요?**
	`struct`에서도 문법적으로 멤버 함수 사용이 가능하지만 , 그렇게 하는 경우는 사실상 없습니다.
	C++에서는 struct / class 차이가 아주 미세하지만 `C#`에서는 기본적으로 `복사/참조 타입`이라는 어마어마한 차이가 있기 때문에 `객체`를 만들 때 무조건 `class`를 활용하게 되기 때문입니다.
	`Program` 내부에서 `static`으로 만들어도 물론 똑같이 동작하게 만들 수 있지만,
	나중에 프로그램이 커지면 코드가 30만줄 단위를 넘어가기도 합니다.
	<u>**특별한 경우가 아니라면 관련 있는 애들끼리 모아놓는게 관리 차원에서 좋습니다.**</u>

 #### [얕은 복사, 깊은 복사](https://inflearn.com/questions/175799) 
- **새로운 객체를 만들어서 값을 다시 정해주는 것** ➡️ 깊은 복사 (`Deep Copy`)
- **동일한 주소(객체)를 참조하는 것(<u>카피하는 척!</u> 만 하는 느낌)** ➡️ 얕은 복사(`Shallow Copy`) 
</br>

- 둘다 복사를 하고 싶은 것인데 `얕은 복사`는 <u>메모리에 있는 데이터를</u> `그대로 복붙`만 한 셈이 됩니다. 
- 그런데 `참조형` 같은 경우에는 메모리 데이터를 그대로 복붙하면 같은 `객체를 참조`하게 됩니다. 
- 가령 Player가 내부적으로 `Inventory`를 갖고 있는 상태에서, 해당 Player를 그대로 복사하면 2 Player가 동일한 Inventory를 공유한다는 의미가 되는데 살짝 이상한 상황이겠죠. 
- 따라서 `깊은 복사`를 할 때는 `메모리 데이터 복붙`을 하는게 아니라 정말 객체의 복사가 의미하는 바를 실행한다고 생각하시면 됩니다.
- <u>일반적인 상황에서는 메모리 값 그대로만 복사하는 것은 의미가 없기 때문에 얕은 복사가 안 되고 깊은 복사를 해야 합니다.</u>
- 하지만 정말 상관없는 경우도 있겠죠. Inventory는 없고 `int hp, int attack` 같은 <u>평범한 정수 수치</u>만 갖고 있다면 그냥 그대로 메모리 값만 복사하면 하면 됩니다.
- 그리고 경우에 따라 Inventory 같은 참조값을 공유해도 딱히 상관없는 경우도 생기는데 예를 들어 Marine 클래스가 `Marine 공방업 정보`를 별도의 참조값으로 들고 있다면, 이 값은 모든 Marine들이 공통적으로 들고 있어도 되니 상관없을 겁니다.

--- 

## 추후 업데이트할 내용 
- [ ]  구조체, 열거형  노트를 추가했다  내용을 보다보니 
깊은 복사, 얕은 복사가 헷갈린다  — 관련 내용 추가 필요
- [x] 관련해서 ref, out 키워드도 C# 기본문법 보고 내용 추가 필요
	➡️ [C# 기본문법 ref, out 내용 추가](https://github.com/Gosome95/TIL/blob/main/CSharp/Method_RefBook.md#%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC-pass-by-value) 