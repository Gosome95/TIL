# 열거형식(Enumerator)과 구조체(Structure)

> 책 <이것이C#이다> 를 참고하였습니다 
> **`mytRPG1_CreatePlayer()`함수까지 구현해보면서 헷갈렸던 [enum 및 sturct] 이론 부분 추가** 

## 상수(Constants)와 열거형식(Enumerator)

- 변수와 달리 안에 담긴 데이터를 절대 바꿀 수 없는 메모리 공간 
- "값을 바꾸지 말아야 할 변수"를 건드리는 실수 방지 
	- 컴파일러가 소스 코드를 컴파일 할 때 프로그래머의 실수를 잡아 알려주고, 프로그램의 버그도 줄여준다

### 상수(Constants)
- 데이터 형식 앞에 `const` 키워드 위치 
- 상수가 가져야 하는 데이터를 반드시 대입해줘야 한다 
```cs
const 자료형 상수명 = 값;

const int a = 3;
const double b = 3.14;
const string c = "abcedef";

a = 4;   // 컴파일 에러를 뱉어줌 
```

### 열거 형식 (Enumerator) - 여러 개의 상수를 정리 
- 종류는 같지만 다른 값을 갖는 상수를 선언해야 할 때 
- **`열거 형식`은 같은 범주에 속하는 여러 개의 상수를 선언할 때 유용하다** 
	- 수백 개의 상수 중에서 만약 중복되는 값을 갖는 상수들이 존재하는 실수를 막아주는 장치
```cs
enum 열거 형식명 : 기반자료형 
{상수1, 상수2, 상수3, ...}

enum 열거형식명 
{
	상수1 = 값1,
	상수2 = 값2,
	상수3 = 값3, .... 	
}
```

- 기반 자료형은 정수 계열 `{byte, sbyte, short, ushort, int, uint, long, ulong, char}`
	- 생략할 경우 컴파일러가 `int`를 기반자료형으로 사용 
- 열거 형식 안에 선언된 상수들이 어떤 값도 할당받지 않으면?
	- 컴파일러가 첫번째 요소에 0, 그리고 1씩 증가한 값을 자동 할당 


#### 내가 선언한 `상수`에 어째서 컴파일러가 마음대로 값을 넣는가?
- 열거 형식의 요소가 어떤 값을 갖느냐는 별 의미가 없기 때문 
- 열거 형식의 각 요소는 서로 중복되지 않는 값을 갖고 있다는데 의미가 있다 
- **각 요소가 갖고 있는 값보다 <u>`각 요소의 이름`을 사용</u>하는 것이 그 의미에 잘 부합한다고 할 수 있다** 
```cs
enum ClassType
{
	None = 0,
	Knight = 1,
	Archer = 2,
	Mage = 3
 }
```
-  enum 구현부 안에 숫자는 반드시 {0, 1, 2, 3}일 필요 없고 {10, 15, 20} 같은 다른 값도 가능
-   `메모리` 상으로는 `일반 정수`이지만 C# 코드에선 `"1"` `"2"` `"3"` 같은 의미없는 하드코딩해서 넣는 것이 아니라 **`ClassType.Knight` 와 같이 알아보기 쉬운 값을 사용**할 수 있게 된다
```cs
DialogResult result = DialogResult.Yes;
```
- `DialogResult가 0이다` 보다는 `DialoResult가 Yes다` 가 훨씬 의미를 잘 전달하고 읽기 좋다.
- 헷갈릴 위험도 적고, 나중에 고치기도 쉬워진다 

</br>

- 앞에서 `enum ClassType` 라는 열거 형식을 선언했는데, `ClassType`는 변수가 아니고 `새로운 형식`!
- 담을 수 있는 데이터는 오로지 `ClassType` `형식`뿐인 새로운 사용자정의 형식 

## 구조체(Structure)
- 클래스(`class`)와 유사

| 특징          | 클래스(Class)                          | 구조체(Structure)                        |
| ------------- | ------------------------------ | -------------------------------- |
| 키워드        | class                          | struct                           |
| 형식          | 참조 형식<br>(힙에 할당)       | 값 형식<br>(스택에 할당)         |
| 복사          | 얕은 복사<br>Shallow Copy      | 깊은 복사<br>Deep Copy           |
| 인스턴스 생성 | new 연산자와 생성자 필요       | 선언만으로도 생성                |
| 생성자        | 매개변수 없는 생성자 선언 가능 | 매개변수 없는 생성자 선언 불가능 |
| 상속          | 가능                           | 값 형식이므로 상속 불가능        |


```cs
struct 구조체이름
{
	// 필드 ... 
	// 메소드 ... 
}
```
</br>

```cs
struct PlayerStatus
{
	public int hp;
	public int attack;
}
```
- 구조체의 필드를 `pulbic`으로 선언했다 
- 클래스는 실세계의 객체를 추상화하려는 데 그 존재의 이유가 있음 
- **<u>구조체는 데이터를 담기 위한 자료구조로 사용</u>** 
- 굳이 은닉성을 비롯한 객체지향의 원칙을 구조체에 강하게 적용하지 않는 편이며, 편의를 위해 `public`으로 선언해서 사용한다

- <u>**클래스는 참조형식이고 구조체는 값 형식**</u>
```cs
Playerstatus player1;
player1.hp = 100;
player1.attack = 10; 

// 구조체의 인스턴스를 다른 인스턴스에 할당하면 (인스턴스) 깊은 복사가 이루어진다 
Playerstatus Player2 = player1;   
palyer2.hp = 80; 

/////////////////
player1 {100, 10}
player2 {80, 10}
```
- 값 형식이기 때문에 모든 필드가 그대로 복사된다 

- 선언만으로도 인스턴스가 생성된다 
	- 생성자를 이용한 인스턴스 생성도 가능
	- 단, 매개변수가 없는 생성자는 선언할 수 없다.
	- 하지만 구조체의 각 필드는 `CLR`이 기본값으로 초기화를 해준다 

### [코드](https://github.com/Gosome95/TIL/blob/main/CSharp/TextRPG1_UseMethod/TextRPG1_02_MakePlayer.cs)에서 열겨형식과 구조체 
> **ClassType은 enum 형태로, Player Stat {hp, attack}은 sturct 형태로 구현한 이유?**

- ClassType은 Knight, Archer, Mage 같은 `직업 종류`를 묶어준다. 직업Class Type이라는 범주 안에서 <u>**Class를 말 그대로 나열한 형태로 사용**</u>
- 실제 ClassType 안에 들어있는 데이터 {0, 1, 2, 3}을 건드릴 일이 없다 
- 반면에 각 직업 안에 들어가는 스텟(stat)정보 `{hp, attack}`은 <u>**직접 데이터를 집어넣어서 조작이 필요**</u>하다 

--- 

## 추후 업데이트할 내용 
- [ ]  구조체, 열거형  노트를 추가했다  내용을 보다보니 
깊은 복사, 얕은 복사가 헷갈린다  — 관련 내용 추가 필요
- [ ]  관련해서 ref, out 키워드도 C# 기본문법 보고 내용 추가 필요
